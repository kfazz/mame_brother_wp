From: Cesare Falco <cesare.falco@gmail.com>
Subject: Fix typos in mess tree to make lintian happier
Index: mame-0.142/mess/docs/messnew.txt
===================================================================
--- mame-0.142.orig/mess/docs/messnew.txt	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/docs/messnew.txt	2011-06-16 10:00:03.000000000 +0200
@@ -7652,7 +7652,7 @@
   [Nate Woods]
 
 - [Win32 GUI] Printers are now treated separately from the other devices; you
-  do not specify printer ouput like you do disk images.  Printer output now
+  do not specify printer output like you do disk images.  Printer output now
   gets specified in the configuration tab of the system properties.  The added
   benefit is that the same output file can be used repeatedly. [Nate Woods]
 
Index: mame-0.142/mess/src/mess/drivers/newbrain.c
===================================================================
--- mame-0.142.orig/mess/src/mess/drivers/newbrain.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/drivers/newbrain.c	2011-06-16 10:00:03.000000000 +0200
@@ -756,7 +756,7 @@
         3       MSPD        1 enables 50K Baud serial data rate to be obtained ie. CTC input clock of 800 kHz. 0 selects xxx.692 kHz
         4       ENOR        1 enables serial receive clock to sound output summer, and also selects serial input from the printer port. 0 selects serial input from the comms port
         5       ANSW        1 enables second bank of 4 analogue inputs (voltage, non-ratiometric), ie. ch4-7, and enabled sound output, 0 selects ch03
-        6       ENOT        1 enables serial transmit clock to sound ouput summer, and also selects serial output to the printer port. 0 selects serial output to the comms port
+        6       ENOT        1 enables serial transmit clock to sound output summer, and also selects serial output to the printer port. 0 selects serial output to the comms port
         7                   9th output bit for centronics printer port
 
     */
Index: mame-0.142/mess/src/mess/machine/thomson.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/thomson.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/thomson.c	2011-06-16 10:00:03.000000000 +0200
@@ -1165,7 +1165,7 @@
 		/* joystick */
 		/* bits 6-7: action buttons A (0=pressed) */
 		/* bits 2-3: action buttons B (0=pressed) */
-		/* bits 4-5: unused (ouput) */
+		/* bits 4-5: unused (output) */
 		/* bits 0-1: unknown! */
 		data = input_port_read(device->machine(), "game_port_buttons");
 	}
Index: mame-0.142/mess/sysinfo.dat
===================================================================
--- mame-0.142.orig/mess/sysinfo.dat	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/sysinfo.dat	2011-06-16 10:00:03.000000000 +0200
@@ -527,7 +527,7 @@
 
   * Sound: Four 8 bit PCM voices, 9 octaves
 
-  * I/O Ports: RGB, RF & composite video ouputs, external floppy disk port, Centronics, RS232c, Expansion port, stereo sound, Atari Compatible joysticks (2), RAM expansion port, keyboard connector
+  * I/O Ports: RGB, RF & composite video outputs, external floppy disk port, Centronics, RS232c, Expansion port, stereo sound, Atari Compatible joysticks (2), RAM expansion port, keyboard connector
 
   * Keyboard: full-size typewriter style, 89 keys, 10 function keys and numeric keypad
 
@@ -21790,7 +21790,7 @@
 
   * Sound: SN76496 sound processor
 
-  * I/O Ports: RGB & composit video ouput (8-pin DIN), mouse, joystick port, keyboard connector (IBM compatible)
+  * I/O Ports: RGB & composit video output (8-pin DIN), mouse, joystick port, keyboard connector (IBM compatible)
 
   * OS: MDOS (very close to MS-DOS)
 
@@ -31759,7 +31759,7 @@
 
   * Sound: 3 voices + pink noise / 6 octaves
 
-  * I/O Ports: Cassette port, Parallel I/O port, 2 x joystick ports, Audio ouput, Composite video output, Cartridge slot, Parallel/Centronics port
+  * I/O Ports: Cassette port, Parallel I/O port, 2 x joystick ports, Audio output, Composite video output, Cartridge slot, Parallel/Centronics port
 
   * Keyboard: Full stroke 79 key with numeric keypad and 8 function keys
 
Index: mame-0.142/mess/hash/megadriv.xml
===================================================================
--- mame-0.142.orig/mess/hash/megadriv.xml	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/hash/megadriv.xml	2011-06-16 10:00:03.000000000 +0200
@@ -16303,7 +16303,7 @@
 		On the Quackshot PCB there is a 512Kb rom.
 		Normally all the address lines from A1 to A19 (the whole 512Kb range) tied to the chip in the right order.
 		But here we have the megadrive A18 line tied to the A20 pin of the rom.
-		This means that the Megadrive sees the first 256Kb of the rom followed by 0xc0000 lenght range of mirrored/zero-ed data 
+		This means that the Megadrive sees the first 256Kb of the rom followed by 0xc0000 length range of mirrored/zero-ed data
 		then again the last 256Kb of the game.
 		I think they did that for a crappy (really crappy) copy protection.
 	-->
Index: mame-0.142/mess/src/mess/drivers/ti99_8.c
===================================================================
--- mame-0.142.orig/mess/src/mess/drivers/ti99_8.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/drivers/ti99_8.c	2011-06-16 10:00:03.000000000 +0200
@@ -49,7 +49,7 @@
     Mapper has 4kb page size (-> 16 pages per map file), 32 bits per page
     entry.  Address bits A0-A3 are the page index, whereas bits A4-A15 are the
     offset in the page.  Physical address space is 16Mbytes.  All pages are 4
-    kBytes in lenght, and they can start anywhere in the 24-bit physical
+    kBytes in length, and they can start anywhere in the 24-bit physical
     address space.  The mapper can load any of 4 map files from SRAM by DMA.
     Map file 0 is used by BIOS, file 1 by memory XOPs(?), file 2 by P-code
     interpreter(???).
Index: mame-0.142/mess/src/mess/formats/hect_tap.c
===================================================================
--- mame-0.142.orig/mess/src/mess/formats/hect_tap.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/formats/hect_tap.c	2011-06-16 10:00:03.000000000 +0200
@@ -118,7 +118,7 @@
        if (data_pos>1)
                 previous_block = casdata[data_pos-1];
 
-		/* Handle block lenght on tape data */
+		/* Handle block length on tape data */
 		block_size = casdata[data_pos] ;
 		if (block_size==0)
 		   block_size=256;
@@ -170,7 +170,7 @@
        /* Starting a block with 768 cycle of synchro*/
        sample_count += hector_tap_synchro( buffer, sample_count, 768 );
 
-		/* Handle block lenght on tape data */
+		/* Handle block length on tape data */
 		block_size = 822 ; /* Fixed size for the forth*/
 
 		/*block_count=0;*/
Index: mame-0.142/mess/src/mess/machine/990_hd.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/990_hd.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/990_hd.c	2011-06-16 10:00:03.000000000 +0200
@@ -29,7 +29,7 @@
 overriden if more than one controller is used */
 #define MAX_DISK_UNIT 4
 
-/* Max sector lenght is bytes.  Generally 256, except for a few older disk
+/* Max sector length is bytes.  Generally 256, except for a few older disk
 units which use 288-byte-long sectors, and SCSI units which generally use
 standard 512-byte-long sectors. */
 /* I chose a limit of 512.  No need to use more until someone writes CD-ROMs
Index: mame-0.142/mess/src/mess/machine/990_tap.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/990_tap.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/990_tap.c	2011-06-16 10:00:03.000000000 +0200
@@ -315,7 +315,7 @@
 		goto update_registers;
 	}
 
-	logerror("read binary forward: rec lenght %d, requested %d\n", reclen, char_count);
+	logerror("read binary forward: rec length %d, requested %d\n", reclen, char_count);
 
 	rec_count = reclen;
 
Index: mame-0.142/mess/src/mess/machine/hecdisk2.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/hecdisk2.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/hecdisk2.c	2011-06-16 10:00:03.000000000 +0200
@@ -210,7 +210,7 @@
 {
 	/* To generate the NMI signal (late) when uPD DMA request*/
 	cputag_set_input_line(machine, "disc2cpu", INPUT_LINE_NMI, ASSERT_LINE);  //NMI...
-	hector_nb_cde =0; // clear the cde lenght
+	hector_nb_cde =0; // clear the cde length
 }
 
 static TIMER_CALLBACK( Callback_INT_irq )
@@ -371,7 +371,7 @@
 	if (print==1)
 		printf(" _%x",data);
 	#endif
-	hector_nb_cde =0; // clear the cde lenght
+	hector_nb_cde =0; // clear the cde length
 	return data;
 }
 WRITE8_HANDLER( hector_disc2_io61_port_w)
@@ -387,7 +387,7 @@
 hector_cmd_2=hector_cmd_1;  //hector_cmd_1 = GPL
 hector_cmd_1=hector_cmd_0;  //hector_cmd_0 = DTL
 hector_cmd_0 = data;
-// Increase the lenght cde!
+// Increase the length cde!
 hector_nb_cde++;
 
 // check if current commande is write cmde.
Index: mame-0.142/mess/src/mess/machine/pce.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/pce.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/pce.c	2011-06-16 10:00:03.000000000 +0200
@@ -1195,7 +1195,7 @@
 		}
 		else
 		{
-			logerror("Succesfully read mode1 frame #%d\n", pce_cd.current_frame );
+			logerror("Successfully read mode1 frame #%d\n", pce_cd.current_frame );
 		}
 
 		pce_cd.data_buffer_index = 0;
Index: mame-0.142/mess/src/mess/machine/strata.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/strata.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/strata.c	2011-06-16 10:00:03.000000000 +0200
@@ -51,7 +51,7 @@
 	int status;			// current status
 	int master_lock;	// master lock flag
 	offs_t wrbuf_base;	// start address in write buffer command
-	int wrbuf_len;		// count converted into byte lenght in write buffer command
+	int wrbuf_len;		// count converted into byte length in write buffer command
 	int wrbuf_count;	// current count in write buffer command
 	UINT8 *wrbuf;		// write buffer used by write buffer command
 	UINT8 *data_ptr;	// main FEEPROM area
Index: mame-0.142/mess/src/mess/machine/wswan.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/wswan.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/wswan.c	2011-06-16 10:00:03.000000000 +0200
@@ -1452,7 +1452,7 @@
 			{
 				state->m_vdp.timer_hblank_reload = 0;
 			}
-			logerror( "trigerring hbltmr interrupt\n" );
+			logerror( "triggering hbltmr interrupt\n" );
 			wswan_set_irq_line( machine, WSWAN_IFLAG_HBLTMR );
 		}
 	}
Index: mame-0.142/mess/src/mess/tools/imgtool/modules/concept.c
===================================================================
--- mame-0.142.orig/mess/src/mess/tools/imgtool/modules/concept.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/tools/imgtool/modules/concept.c	2011-06-16 10:00:03.000000000 +0200
@@ -409,7 +409,7 @@
 	free_blocks = get_UINT16xE(image->dev_dir.vol_hdr.disk_flipped, image->dev_dir.vol_hdr.last_block)
 					- get_UINT16xE(image->dev_dir.vol_hdr.disk_flipped, image->dev_dir.vol_hdr.next_block);
 
-	/* next substract lenght of each file */
+	/* next substract length of each file */
 	for (i=0; (image->dev_dir.file_dir[i].filename[0] != 0) && (i <= 77); i++)
 	{
 		free_blocks -= get_UINT16xE(image->dev_dir.vol_hdr.disk_flipped, image->dev_dir.file_dir[i].next_block)
Index: mame-0.142/mess/src/mess/tools/imgtool/modules/ti99.c
===================================================================
--- mame-0.142.orig/mess/src/mess/tools/imgtool/modules/ti99.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/tools/imgtool/modules/ti99.c	2011-06-16 10:00:03.000000000 +0200
@@ -64,11 +64,11 @@
     "fphysrecs".
 
     Programs do normally not access file physical records directly.  They may
-    call high-level file routines that enable to create either fixed-lenght
-    logical records of any size from 1 through 255, or variable-lenght records
+    call high-level file routines that enable to create either fixed-length
+    logical records of any size from 1 through 255, or variable-length records
     of any size from 0 through 254: logical records are grouped by file
     managers into 256-byte physical records.  Some disk managers (HFDC and
-    SCSI) allow programs to create fixed-lenght records larger than 255 bytes,
+    SCSI) allow programs to create fixed-length records larger than 255 bytes,
     too, but few programs use this possibility.  Additionally, program files
     can be created: program files do not implement any logical record, and can
     be seen as a flat byte stream, not unlike files under MSDOS, UNIX and the C
@@ -93,11 +93,11 @@
                                                                 \_/
                                                                unused
 
-        Variable lenght records are grouped like this:
+        Variable length records are grouped like this:
                              fphysrec 0:
             byte:
                     ------------------------------
-                  0 |l0 = lenght of record 0 data|
+                  0 |l0 = length of record 0 data|
                     |----------------------------|
                   1 |                            |
                     |                            |
@@ -105,7 +105,7 @@
                     |                            |
                  l0 |                            |
                     |----------------------------|
-               l0+1 |l1 = lenght of record 1 data|
+               l0+1 |l1 = length of record 1 data|
                     |----------------------------|
                l0+2 |                            |
                     |                            |
@@ -116,7 +116,7 @@
                   : :                            :
                   : :                            :
                     |----------------------------|
-                  n |lm = lenght of record m data|
+                  n |lm = length of record m data|
                     |----------------------------|
                 n+1 |                            |
                     |                            |
@@ -137,7 +137,7 @@
                              fphysrec 1:
             byte:
                     ------------------------------
-                  0 |lm+1=lenght of record 0 data|
+                  0 |lm+1=length of record 0 data|
                     |----------------------------|
                   1 |                            |
                     |                            |
@@ -203,7 +203,7 @@
     Remaining AUs are used for fdr and data (and subdirectory FDIR if
     applicable).  There is one FDIR record per directory; the FDIR points to
     the FDR for each file in the directory.  The FDR (File Descriptor Record)
-    contains the file information (name, format, lenght, pointers to data
+    contains the file information (name, format, length, pointers to data
     physrecs/AUs, etc).
 
 
@@ -253,7 +253,7 @@
 /* Since string length is encoded with a byte, the maximum length of a string
 is 255.  Since we need to add a device name (1 char minimum, typically 4 chars)
 and a '.' separator, we chose a practical value of 250 (though few applications
-will accept paths of such lenght). */
+will accept paths of such length). */
 #define MAX_PATH_LEN 253
 #define MAX_SAFE_PATH_LEN 250
 
@@ -334,7 +334,7 @@
 
     dst (O): destination C string
     src (I): source 10-character array
-    n (I): lenght of dst buffer (string may be truncated if less than 11)
+    n (I): length of dst buffer (string may be truncated if less than 11)
 */
 static void fname_to_str(char *dst, const char src[10], int n)
 {
@@ -421,7 +421,7 @@
 	if ((strlen(fpath) > MAX_PATH_LEN) || strchr(fpath, ' '))
 		return 1;
 
-	/* check that each path element has an acceptable lenght */
+	/* check that each path element has an acceptable length */
 	element_start = fpath;
 	do
 	{
@@ -548,7 +548,7 @@
 	imgtool_stream *file_handle;		/* imgtool file handle */
 	struct mess_hard_disk_file harddisk_handle;		/* MAME harddisk handle (harddisk format) */
 	ti99_geometry geometry;		/* geometry */
-	unsigned pc99_track_len;		/* unformatted track lenght (pc99 format) */
+	unsigned pc99_track_len;		/* unformatted track length (pc99 format) */
 	UINT32 *pc99_data_offset_array;	/* offset for each sector (pc99 format) */
 } ti99_lvl1_imgref;
 
@@ -591,7 +591,7 @@
     vib (O): buffer where the vib should be stored (first pass)
     geometry (O): disk image geometry (second pass)
     data_offset_array (O): array of data offset to generate (second pass)
-    out_track_len (O): track lenght is returned there
+    out_track_len (O): track length is returned there
 
     Return imgtool error code
 */
@@ -599,7 +599,7 @@
 #define DATA_OFFSET_NONE 0xffffffff
 static int parse_pc99_image(imgtool_stream *file_handle, int fm_format, int pass, dsk_vib *vib, const ti99_geometry *geometry, UINT32 *data_offset_array, unsigned *out_track_len)
 {
-	int track_len, num_tracks;	/* lenght of a track in bytes, and number of tracks */
+	int track_len, num_tracks;	/* length of a track in bytes, and number of tracks */
 	int phys_track;
 	int expected_cylinder, expected_head;
 	int track_start_pos, track_pos;
@@ -1574,7 +1574,7 @@
 								/* chain (i.e. rounded on the next AU */
 								/* boundary), so level-3 routines should use */
 								/* the fixrecs field instead to determine the */
-								/* logical lenght of field.  IIRC, the HFDC */
+								/* logical length of field.  IIRC, the HFDC */
 								/* implementation is regarded as a bug because */
 								/* program files do not define the fixrecs field */
 								/* field, so program field saved by the HFDC */
@@ -1620,7 +1620,7 @@
 								/* chain (i.e. rounded on the next AU */
 								/* boundary), so level-3 routines should use */
 								/* the fixrecs field instead to determine the */
-								/* logical lenght of field.  IIRC, the HFDC */
+								/* logical length of field.  IIRC, the HFDC */
 								/* implementation is regarded as a bug because */
 								/* program files do not define the fixrecs field */
 								/* field, so program field saved by the HFDC */
@@ -2505,14 +2505,14 @@
 	search_start = dsk_file->l2_img->data_offset;	/* initially, search for free space only in data space */
 	while (nb_alloc_physrecs)
 	{
-		/* find smallest data block at least nb_alloc_physrecs in lenght, and largest data block less than nb_alloc_physrecs in lenght */
+		/* find smallest data block at least nb_alloc_physrecs in length, and largest data block less than nb_alloc_physrecs in length */
 		first_best_block_seclen = INT_MAX;
 		second_best_block_seclen = 0;
 		for (i=search_start; i<totAUs; i++)
 		{
 			if (! (dsk_file->l2_img->abm[i >> 3] & (1 << (i & 7))))
 			{	/* found one free block */
-				/* compute its lenght */
+				/* compute its length */
 				cluster_baseAU = i;
 				cur_block_seclen = 0;
 				while ((i<totAUs) && (! (dsk_file->l2_img->abm[i >> 3] & (1 << (i & 7)))))
@@ -2689,14 +2689,14 @@
 	search_start = win_file->l2_img->data_offset;	/* initially, search for free space only in data space */
 	while (nb_alloc_physrecs)
 	{
-		/* find smallest data block at least nb_alloc_physrecs in lenght, and largest data block less than nb_alloc_physrecs in lenght */
+		/* find smallest data block at least nb_alloc_physrecs in length, and largest data block less than nb_alloc_physrecs in length */
 		first_best_block_seclen = INT_MAX;
 		second_best_block_seclen = 0;
 		for (i=search_start; i<totAUs; i++)
 		{
 			if (! (win_file->l2_img->abm[i >> 3] & (1 << (i & 7))))
 			{	/* found one free block */
-				/* compute its lenght */
+				/* compute its length */
 				cluster_baseAU = i;
 				cur_block_seclen = 0;
 				while ((i<totAUs) && (! (win_file->l2_img->abm[i >> 3] & (1 << (i & 7)))))
@@ -3765,7 +3765,7 @@
 	}
 	else if (flags & fdr99_f_var)
 	{
-		/* variable-lenght records */
+		/* variable-length records */
 		if (is_eof(l3_file))
 			return IMGTOOLERR_UNEXPECTED;
 		errorcode = read_file_physrec(&l3_file->l2_file, l3_file->cur_phys_rec, physrec_buf);
Index: mame-0.142/mess/src/mess/tools/imgtool/modules/ti990hd.c
===================================================================
--- mame-0.142.orig/mess/src/mess/tools/imgtool/modules/ti990hd.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/tools/imgtool/modules/ti990hd.c	2011-06-16 10:00:03.000000000 +0200
@@ -14,7 +14,7 @@
 #include "osdepend.h"
 #include "imgtoolx.h"
 
-/* Max sector lenght is bytes.  Generally 256, except for a few older disk
+/* Max sector length is bytes.  Generally 256, except for a few older disk
 units which use 288-byte-long sectors, and SCSI units which generally use
 standard 512-byte-long sectors. */
 /* I chose a limit of 512.  No need to use more until someone creates CD-ROMs
@@ -529,7 +529,7 @@
     address: physical sector address
     geometry: disk geometry (sectors per track, tracks per side, sides)
     dest: pointer to destination buffer
-    len: lenght of data to read
+    len: length of data to read
 */
 static int read_sector_physical_len(imgtool_stream *file_handle, const ti990_phys_sec_address *address, const ti990_geometry *geometry, void *dest, int len)
 {
@@ -572,7 +572,7 @@
     address: physical sector address
     geometry: disk geometry (sectors per track, tracks per side, sides)
     src: pointer to source buffer
-    len: lenght of source buffer
+    len: length of source buffer
 */
 static int write_sector_physical_len(imgtool_stream *file_handle, const ti990_phys_sec_address *address, const ti990_geometry *geometry, const void *src, int len)
 {
@@ -634,7 +634,7 @@
     secnum: logical sector address
     geometry: disk geometry (sectors per track, tracks per side, sides)
     dest: pointer to destination buffer
-    len: lenght of data to read
+    len: length of data to read
 */
 static int read_sector_logical_len(imgtool_stream *file_handle, int secnum, const ti990_geometry *geometry, void *dest, int len)
 {
@@ -668,7 +668,7 @@
     secnum: logical sector address
     geometry: disk geometry (sectors per track, tracks per side, sides)
     src: pointer to source buffer
-    len: lenght of source buffer
+    len: length of source buffer
 */
 static int write_sector_logical_len(imgtool_stream *file_handle, int secnum, const ti990_geometry *geometry, const void *src, int len)
 {
@@ -957,14 +957,14 @@
 	search_start = image->data_offset;	/* initially, search for free space only in data space */
 	while (nb_alloc_sectors)
 	{
-		/* find smallest data block at least nb_alloc_sectors in lenght, and largest data block less than nb_alloc_sectors in lenght */
+		/* find smallest data block at least nb_alloc_sectors in length, and largest data block less than nb_alloc_sectors in length */
 		first_best_block_len = INT_MAX;
 		second_best_block_len = 0;
 		for (i=search_start; i<totsecs; i++)
 		{
 			if (! (image->sec0.abm[i >> 3] & (1 << (i & 7))))
 			{	/* found one free block */
-				/* compute its lenght */
+				/* compute its length */
 				cur_block_start = i;
 				cur_block_len = 0;
 				while ((i<totsecs) && (! (image->sec0.abm[i >> 3] & (1 << (i & 7)))))
Index: mame-0.142/mess/src/mess/devices/coco_vhd.c
===================================================================
--- mame-0.142.orig/mess/src/mess/devices/coco_vhd.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/devices/coco_vhd.c	2011-06-16 10:00:03.000000000 +0200
@@ -26,7 +26,7 @@
     Error values:
 
      0 = no error
-    -1 = power-on state (before the first command is recieved)
+    -1 = power-on state (before the first command is received)
     -2 = invalid command
      2 = VHD image does not exist
      4 = Unable to open VHD image file
Index: mame-0.142/mess/src/mess/drivers/dectalk.c
===================================================================
--- mame-0.142.orig/mess/src/mess/drivers/dectalk.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/drivers/dectalk.c	2011-06-16 10:00:03.000000000 +0200
@@ -17,7 +17,7 @@
 *    * pins IP0, IP2, and IP3 are connected to the primary serial port:
 *      * IP0 is CTS
 *      * IP2 is DSR
-*      * IP3 is RLS (recieved line signal, this pin is rarely used on rs232)
+*      * IP3 is RLS (received line signal, this pin is rarely used on rs232)
 *    * <DONE> pins IP4, IP5 and IP6 are on jumpers on the DUART, tied high normally but jumperable low, should be handled as dipswitches:
 *      * IP4 low: skip hardware self tests
 *      * IP5 low: unknown
Index: mame-0.142/mess/src/mess/drivers/fm7.c
===================================================================
--- mame-0.142.orig/mess/src/mess/drivers/fm7.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/drivers/fm7.c	2011-06-16 10:00:03.000000000 +0200
@@ -659,19 +659,19 @@
 		case 1:  // get keyboard scancode mode
 			state->m_encoder.buffer[0] = state->m_key_scan_mode;
 			state->m_encoder.rx_count = 1;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 2:  // set LEDs
 			state->m_encoder.rx_count = 0;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 3:  // get LEDs
 			state->m_encoder.rx_count = 1;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 4:  // enable key repeat
 			state->m_encoder.rx_count = 0;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 5:  // set key repeat rate
 			state->m_key_repeat = state->m_encoder.buffer[2] * 10;
@@ -684,23 +684,23 @@
 				state->m_encoder.rx_count = 0;
 			else
 				state->m_encoder.rx_count = 7;
-			logerror("ENC: Command %02x %02x recieved\n",state->m_encoder.buffer[0],state->m_encoder.buffer[1]);
+			logerror("ENC: Command %02x %02x received\n",state->m_encoder.buffer[0],state->m_encoder.buffer[1]);
 			break;
 		case 0x81:  // digitise
 			state->m_encoder.rx_count = 0;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 0x82:  // set screen mode
 			state->m_encoder.rx_count = 0;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 0x83:  // get screen mode
 			state->m_encoder.rx_count = 1;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 		case 0x84:  // set monitor brightness
 			state->m_encoder.rx_count = 0;
-			logerror("ENC: Command %02x recieved\n",state->m_encoder.buffer[0]);
+			logerror("ENC: Command %02x received\n",state->m_encoder.buffer[0]);
 			break;
 	}
 	state->m_encoder.position = 0;
Index: mame-0.142/mess/src/mess/machine/er59256.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/er59256.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/er59256.c	2011-06-16 10:00:03.000000000 +0200
@@ -38,7 +38,7 @@
     UINT16  in_shifter;
     UINT32  out_shifter;
 
-    /* Count of bits recieved since last CS low->high */
+    /* Count of bits received since last CS low->high */
     UINT8   bitcount;
 
     /* Command & addresss */
Index: mame-0.142/mess/src/mess/machine/x68k_hdc.c
===================================================================
--- mame-0.142.orig/mess/src/mess/machine/x68k_hdc.c	2011-06-16 09:59:15.000000000 +0200
+++ mame-0.142/mess/src/mess/machine/x68k_hdc.c	2011-06-16 10:00:03.000000000 +0200
@@ -294,7 +294,7 @@
 					sasi->io = 1;  // Output
 					sasi->status_port |= 0x04;  // C/D remains the same
 					sasi->status = 0x02;
-					logerror("SASI: Invalid or unimplemented SASI command (0x%02x) recieved.\n",sasi->command[0]);
+					logerror("SASI: Invalid or unimplemented SASI command (0x%02x) received.\n",sasi->command[0]);
 				}
 			}
 		}
Index: mame-0.142/mess/src/mess/drivers/primo.c
===================================================================
--- mame-0.142.orig/mess/src/mess/drivers/primo.c	2011-06-16 10:10:56.000000000 +0200
+++ mame-0.142/mess/src/mess/drivers/primo.c	2011-06-16 10:11:10.000000000 +0200
@@ -384,7 +384,7 @@
 
 ROM_START( primob64 )
 	ROM_REGION( 0x1c000, "maincpu", ROMREGION_ERASEFF )
-	ROM_SYSTEM_BIOS(0, "standart", "Standart")
+	ROM_SYSTEM_BIOS(0, "standard", "Standard")
 	ROMX_LOAD( "b64.rom",     0x10000, 0x4000, CRC(cea28188) SHA1(a77e42e97402e601b78ab3751eac1e85d0bbb4a0), ROM_BIOS(1) )
 	ROM_SYSTEM_BIOS(1, "cdos", "CDOS")
 	ROMX_LOAD( "b64cdos.rom", 0x10000, 0x4000, CRC(73305e4d) SHA1(c090c3430cdf19eed8363377b981e1c21a4ed169), ROM_BIOS(2) )
